<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>GPS Tracker em Tempo Real</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 15px;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 600px;
        }
        h1 {
            color: #bb86fc;
            text-align: center;
            margin-bottom: 25px;
        }
        h2 {
            border-bottom: 2px solid #03dac6;
            padding-bottom: 8px;
            color: #03dac6;
            font-size: 1.2em;
        }
        .data-point {
            margin-bottom: 20px;
        }
        .label {
            font-weight: bold;
            color: #cfcfcf;
        }
        .value {
            font-family: 'Courier New', Courier, monospace;
            background-color: #333;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 1.1em;
            color: #fff;
            display: inline-block;
            margin-top: 5px;
        }
        #status {
            text-align: center;
            padding: 10px;
            background-color: #3700b3;
            color: white;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Análise de Navegação</h1>
    <div id="status">Aguardando permissão e sinal de GPS...</div>

    <div class="data-point">
        <h2>Média dos Últimos 3 Segundos</h2>
        <span class="label">LAT/LONG Média:</span>
        <span id="media_recente" class="value">--</span>
    </div>

    <div class="data-point">
        <h2>Média de 9 a 11 Segundos Atrás</h2>
        <span class="label">LAT/LONG Média:</span>
        <span id="media_antiga" class="value">--</span>
    </div>

    <hr style="border-color: #444;">

    <div class="data-point">
        <h2>Resultados Calculados</h2>
        <p>
            <span class="label">Velocidade Média:</span>
            <span id="velocidade" class="value">--</span>
        </p>
        <p>
            <span class="label">Direção Média (Graus Verdadeiros):</span>
            <span id="direcao" class="value">--</span>
        </p>
    </div>
</div>

<script>
    // --- ELEMENTOS DO DOM ---
    const statusEl = document.getElementById('status');
    const mediaRecenteEl = document.getElementById('media_recente');
    const mediaAntigaEl = document.getElementById('media_antiga');
    const velocidadeEl = document.getElementById('velocidade');
    const direcaoEl = document.getElementById('direcao');

    // --- ARMAZENAMENTO E CONFIGURAÇÕES ---
    let historicoPontos = [];
    const TEMPO_MAX_HISTORICO = 15000; // Manter apenas 15 segundos de dados

    // --- FUNÇÕES DE CÁLCULO (sem alterações) ---
    function calcularMediaLatLon(pontos) {
        if (pontos.length === 0) return null;
        const soma = pontos.reduce((acc, p) => ({ lat: acc.lat + p.lat, lon: acc.lon + p.lon }), { lat: 0, lon: 0 });
        return { lat: soma.lat / pontos.length, lon: soma.lon / pontos.length };
    }

    function haversine(ponto1, ponto2) {
        const R = 6371e3;
        const toRadians = (deg) => deg * (Math.PI / 180);
        const dLat = toRadians(ponto2.lat - ponto1.lat);
        const dLon = toRadians(ponto2.lon - ponto1.lon);
        const lat1 = toRadians(ponto1.lat);
        const lat2 = toRadians(ponto2.lat);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    function calcularDirecao(pontoInicial, pontoFinal) {
        const toRadians = (deg) => deg * (Math.PI / 180);
        const toDegrees = (rad) => rad * (180 / Math.PI);
        const lat1 = toRadians(pontoInicial.lat);
        const lon1 = toRadians(pontoInicial.lon);
        const lat2 = toRadians(pontoFinal.lat);
        const lon2 = toRadians(pontoFinal.lon);
        const dLon = lon2 - lon1;
        const y = Math.sin(dLon) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
        return (toDegrees(Math.atan2(y, x)) + 360) % 360;
    }
    
    // --- LÓGICA PRINCIPAL COM GEOLOCATION API ---
    function processarPosicao(posicao) {
        statusEl.textContent = "GPS Ativo. Calculando...";
        statusEl.style.backgroundColor = '#018786';

        const { latitude, longitude } = posicao.coords;
        const timestamp = Date.now();
        
        // Adiciona o novo ponto e remove os antigos
        historicoPontos.push({ lat: latitude, lon: longitude, timestamp: timestamp });
        historicoPontos = historicoPontos.filter(p => timestamp - p.timestamp < TEMPO_MAX_HISTORICO);

        // Filtra os pontos para os dois períodos de tempo
        const pontosRecentes = historicoPontos.filter(p => timestamp - p.timestamp <= 3000);
        const pontosAntigos = historicoPontos.filter(p => {
            const tempoAtras = timestamp - p.timestamp;
            return tempoAtras >= 9000 && tempoAtras <= 11000;
        });

        // Calcula as médias apenas se tivermos dados em ambos os períodos
        const mediaRecente = calcularMediaLatLon(pontosRecentes);
        const mediaAntiga = calcularMediaLatLon(pontosAntigos);

        if (mediaRecente) {
            mediaRecenteEl.textContent = `${mediaRecente.lat.toFixed(6)}, ${mediaRecente.lon.toFixed(6)}`;
        } else {
            mediaRecenteEl.textContent = "Aguardando dados...";
        }

        if (mediaAntiga) {
            mediaAntigaEl.textContent = `${mediaAntiga.lat.toFixed(6)}, ${mediaAntiga.lon.toFixed(6)}`;
        } else {
            mediaAntigaEl.textContent = "Aguardando dados...";
        }

        if (mediaRecente && mediaAntiga) {
            const distanciaMetros = haversine(mediaAntiga, mediaRecente);
            const tempoSegundos = 9;
            const velocidadeKnots = (distanciaMetros / tempoSegundos) * 1.94384;
            const direcaoGraus = calcularDirecao(mediaAntiga, mediaRecente);
            
            velocidadeEl.textContent = `${velocidadeKnots.toFixed(2)} knots`;
            direcaoEl.textContent = `${direcaoGraus.toFixed(1)}°`;
        } else {
            velocidadeEl.textContent = "Dados insuficientes";
            direcaoEl.textContent = "Dados insuficientes";
        }
    }

    function tratarErro(erro) {
        let msg;
        switch (erro.code) {
            case erro.PERMISSION_DENIED:
                msg = "Permissão para acessar a localização foi negada.";
                break;
            case erro.POSITION_UNAVAILABLE:
                msg = "Informação de localização não está disponível.";
                break;
            case erro.TIMEOUT:
                msg = "A solicitação de localização expirou.";
                break;
            default:
                msg = "Ocorreu um erro desconhecido.";
                break;
        }
        statusEl.textContent = msg;
        statusEl.style.backgroundColor = '#cf6679'; // Cor de erro
    }

    // Inicia o monitoramento
    if ('geolocation' in navigator) {
        navigator.geolocation.watchPosition(processarPosicao, tratarErro, {
            enableHighAccuracy: true, // Pede a maior precisão possível (usa o GPS)
            maximumAge: 0,            // Não usar cache de posições antigas
            timeout: 10000            // Tempo máximo para obter uma posição
        });
    } else {
        statusEl.textContent = "Geolocalização não é suportada por este navegador.";
        statusEl.style.backgroundColor = '#cf6679';
    }

</script>

</body>
</html>
